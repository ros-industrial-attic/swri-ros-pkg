#summary Provides guidelines for ROS node functionality, to improve cross-platform compatibility.

<font size="5">*Overview*</font>
<wiki:toc max_depth="2"/>
<BR><BR>
----
= Motivation =
----

One of the primary benefits of ROS-Industrial is that it enables interoperability between robots from different vendors, by integrating their control with the common ROS framework.  Even though ROS integration is a good start, even better compatibility is achieved when these different ROS nodes all utilize a common set of interfaces for control and feedback.

This page attempts to provide some guidelines on what specific ROS interfaces should be provided by a ROS-Industrial robot to ensure maximum compatibility.  It is expected that vendor-specific implementation details may require compromises in some areas, but this will hopefully provide a “gold standard” implementation description.  See below for details on a [ReferenceImplementation Reference Implementation] following these guidelines and a [HardwareCompatibility Hardware Compatibility List] that provides platform-specific information.
----
= Operation =
----
This section describes how the robot is expected to respond to high-level operational activities (e.g. startup, shutdown, etc.).

== Initialization ==
 * the ROS node should automatically initialize all connections to the robot controller
   * _no manual `connect` service-call should be required_<P>
 * it is preferred to have any robot-side code automatically running on controller startup
   * e.g. in a background, always-on task
   * any startup requirements should be explicitly stated in the node's documentation

== Communications ==
 * both sides of the robot-ROS connection should handle communications-loss scenarios:
   * the *ROS node* should...
     * automatically try to reconnect to the robot (at ~1Hz intervals)
     * stop publishing most messages (e.g. position feedback)
     * continue publishing state messages, with `connected=false`
   * the *robot* should...
     * stop motion and power off the drives
     * reinitialize all communications to wait for a new connection
   * if the interface cannot detect comms-loss directly, it may be necessary to implement a heartbeat message between the robot/ROS sides<P>
 * no mechanism is specified to flag something as *unsupported*
   * topics should not be published (or subscribed to) if unsupported
   * if a service call is advertised by a node, it is assumed to be supported (i.e. return valid results)
     * _standard ROS mechanisms will ensure the client gets an error if it calls an unimplemented service_
----
= ROS API =
----
This section describes specific ROS interfaces (topics, services, and parameters) that the robot should provide.  These capabilities may be provided by a single node or multiple nodes, as needed by the robot communications architecture.

It is also possible that different nodes may be used to provide the same capabilities with different assumptions, communications methods, etc.  ROS launch files can be used to control which nodes are appropriate to run for a given application.

== General ==

 === Parameters ===
  * `~address` (`string`)
    * address of robot connection (e.g. IP address)
      * _see robot-specific implementation for details_<P>
  * `robot_description` (`urdf map`)
    * The [http://www.ros.org/wiki/urdf urdf] xml robot description

 === Services ===
  * `reset` ([http://www.ros.org/doc/api/std_srvs/html/srv/Empty.html std_srvs/Empty])
    * Re-initialize the robot connection (disconnect/reconnect)

== State Feedback ==

 === Published Topics ===
  * `feedback_states` ([http://ros.org/doc/fuerte/api/control_msgs/html/msg/FollowJointTrajectoryFeedback.html control_msgs/FollowJointTrajectoryFeedback])
    * provide feedback of current vs. desired joint position (and velocity/acceleration)
    * used by ROS-I's [http://code.google.com/p/swri-ros-pkg/source/browse/trunk/motoman/dx100/src/joint_trajectory_action.cpp joint_trajectory_action] to monitor in-progress motions
      * joint names, ordering, and scale should match ROS conventions (_e.g. joints ordered from base-to-tool, angles in radians, etc._)
      * if `desired` and `error` values unavailable, leave arrays *empty*
      * if `velocities` and `accelerations` unavailable, leave arrays *empty*<P>
  * `joint_states` ([http://www.ros.org/doc/api/sensor_msgs/html/msg/JointState.html sensor_msgs/JointState])
    * provide feedback of current joint position (and velocity/effort)
    * used by the [http://www.ros.org/wiki/robot_state_publisher robot_state_publisher] node to broadcast kinematic transforms
      * joint names, ordering, and scale should match ROS conventions (_e.g. radians_)
      * if `velocity` and `effort` unavailable, leave arrays *empty*<P>
  * `robot_status` ([http://code.google.com/p/swri-ros-pkg/source/browse/trunk/industrial_core/industrial_msgs/msg/RobotStatus.msg industrial_msgs/RobotStatus])
    * provide current status of critical robot parameters
    * used by application code to monitor and react to different fault conditions
      * we prefer using explicit message-fields (instead of [http://www.ros.org/wiki/diagnostics Diagnostics] package) for better client-code usability
      * status values should be set to -1 if not yet available/implemented

 === Services ===
  _All services should return a value, so the client knows if the call succeeded or failed._
  * `get_robot_info` ([http://code.google.com/p/swri-ros-pkg/source/browse/trunk/industrial_core/industrial_msgs/srv/GetRobotInfo.srv industrial_msgs/GetRobotInfo])
    * Get descriptive info from the connected robot<P>
  * `set_remote_logger_level` ([http://code.google.com/p/swri-ros-pkg/source/browse/trunk/industrial_core/industrial_msgs/srv/SetRemoteLoggerLevel.srv industrial_msgs/SetRemoteLoggerLevel])
    * Control message-logging in the robot-side code.
      * intended to reduce network traffic if performance is affected.
      * _may not be able to inhibit *printing* of robot system-generated messages, but can still prevent logging those into the ROS framework_

 === Parameters ===
  * `~state_feedback\port` (`int`)
    * robot-side port number to connect to for state feedback

== Motion Control ==
This node implements methods to control the robot's movement.

Several different types of control may be implemented (trajectory download, streaming points, force-control, etc.), and may not all be compatible with each other.  The robot implementation can provide these methods in a single "master motion node", or as discrete single-purpose nodes.  _It is up to the implementation to ensure that conflicting input from different motion controllers is handled properly._  in general, only one controller should be commanding robot motion at a time.  For complex systems, it may be appropriate to have a "motion manager" node that aggregates and prioritizes competing commands coming from different motion controllers.

 === Subscribed Topics ===
  * `joint_path_command` ([http://www.ros.org/doc/api/trajectory_msgs/html/msg/JointTrajectory.html trajectory_msgs/JointTrajectory])
    * execute a pre-calculated joint trajectory on the robot
    * used by ROS's trajectory generators (e.g. [http://www.ros.org/wiki/joint_trajectory_action joint_trajectory_action]) to issue motion commands
      * often, the entire trajectory is downloaded to the robot, then executed
        * _if necessary, download the trajectory point-by-point, then execute all at once_
        * alternatively, this could stream the individual path points to the !JointCommand interface _(see below)_
      * if the trajectory size exceeds the maximum size (_robot-specific_), the node should ignore the trajectory and log an error
        * _it may be necessary for calling code to use a downsampling filter before this node, to reduce the path size_
      * the robot should attempt to automatically start motion, if possible
        * _this may require enabling drives, executing a motion task, etc._
      * motion should stop (but drives stay on) when the trajectory is completed
      * if a new trajectory is received while an existing motion is in-progress:
        # cancel the current motion (_robot motion may stop_)
        # start the new trajectory
      * currently, the `time_from_start` field is ignored.
        * all trajectory points are executed in-sequence, using the specified velocities.
        * _NOTE: if a non-deterministic protocol (e.g. UDP) is used for transmitting the trajectory to the robot, some method should be used to ensure that the correct sequence is maintained_<P>
  * `joint_command` ([http://www.ros.org/doc/api/trajectory_msgs/html/msg/JointTrajectoryPoint.html trajectory_msgs/JointTrajectoryPoint])
    * execute dynamic motion by streaming joint commands on-the-fly
    * used by client code to control robot position in "real-time"
      * the robot implementation may use a small buffer to allow smooth motion between successive points
      * the topic publisher is responsible for providing new commands at sufficient rate to keep up with robot motion.
        * _denser paths (or faster robot motion) will require higher update rates_
      * this node should monitor the topic stream to ensure points are not received out-of-order (e.g. using `time_from_start`).
        * commands from the past should be dropped.
      * if commands are received faster than the robot can process, behavior may be implementation-dependent:
        # *preferred*: immediately cancel current motion and begin move to new point.  As long as motion remains smooth.
        # *alternative*: new commands will replace the previous most-recent command on the robot-side command queue.

 === Services ===
  _All services should return a value, so the client knows if the call succeeded or failed._
  * `set_drive_power` ([http://code.google.com/p/swri-ros-pkg/source/browse/trunk/industrial_core/industrial_msgs/srv/SetDrivePower.srv industrial_msgs/SetDrivePower])
    * Try to turn on/off drive power<P>
  * `stop_motion` ([http://code.google.com/p/swri-ros-pkg/source/browse/trunk/industrial_core/industrial_msgs/srv/StopMotion.srv industrial_msgs/StopMotion])
    * stop current robot motion
    * can resume motion using `start_motion` or by sending a new motion command<P>
  * `start_motion` ([http://code.google.com/p/swri-ros-pkg/source/browse/trunk/industrial_core/industrial_msgs/srv/StartMotion.srv industrial_msgs/StartMotion])
    * resume current robot motion (e.g. after `stop_motion` or robot fault)
    * will automatically try to re-enable drive power, if necessary

 === Parameters ===
  * `~motion_command\port` (`int`)
    * robot-side port number to connect to for motion commands

== Kinematics ==
To enable real-time motion planning and collision avoidance, the node should provide robot-specific inverse kinematics solutions.  A generic solver is provided in ROS, but it operates too slowly for collision-avoidance path planning.  As described [http://www.ros.org/wiki/arm_navigation/Tutorials/Running%20arm%20navigation%20on%20non-PR2%20arm here] and [http://www.ros.org/wiki/Industrial/Tutorials/Create_a_Fast_IK_Solution here], the [http://openrave.org/docs/latest_stable/openravepy/ikfast/ ikfast] tool can be used to generate the required kinematics files for any 6-DOF serial manipulator.  These files should be integrated with ROS as a *plugin*, not a *service*, to avoid expensive communications-related overhead.  This involves creating a launch file to connect your plugin with the ROS arm_kinematics_constraint_aware node, as described [http://www.ros.org/wiki/arm_kinematics_constraint_aware/Tutorials/Configuring%20kinematics%20for%20your%20arm here].

== Path Accuracy ==
The motion interfaces outlined above do not specify the required accuracy for following a particular trajectory.  The level of path accuracy achieved will depend on limitations of the specific robot, controller, and ROS-interface driver.

  === Collision Padding ===
  The ROS path planners and collision checkers use high-order smoothing of trajectories between waypoints.  The resulting trajectory, as executed by the robot controller, will follow a similar “smooth” trajectory, _but may not exactly match the "ideal" planned trajectory_.  For this reason, the ROS path planners add a specified amount of “padding” to the robot models to account for differences between the planned and actual paths.  This results in a very high probability of collision-free motion.   Increasing the level of padding reduces the chance of collisions.

  A closer integration between path planners and robot controllers would reduce both the path-execution error and the collision-padding requirement.  However, this level of integration is beyond the scope of current ROS-Industrial efforts and may require robot-specific solutions.
<P><BR><BR>
----
= Implementation =
----
This section provides details on current implementations of ROS-Industrial, and how closely they follow these guidelines.

== Essential Capabilities ==
The following capabilities are essential for robots to interact smoothly with other ROS-Industrial components:
  * publish `feedback_states`
    * _at a minimum, the `names` and `positions` fields_
  * publish `joint_states`
    * _at a minimum, the `names` and `actual\positions` fields_
  * subscribe to `JointPathCommand`
    * _at a minimum, execute the joint-positions in sequence at a default velocity_

== Reference Implementation ==
A reference implementation of a ROS-Industrial node implementing these capabilities can be found [http://code.google.com/p/swri-ros-pkg/source/browse/#svn/trunk/industrial_core/socket_client here].  This implementation uses a simple message-based socket protocol to communicate with industrial robots.

New robot implementations are encouraged to consider using this client, if appropriate, for their robot.  See the ABB and Motoman implementations for examples of how to integrate a robot-side server application with a ROS-Industrial client node derived from this reference implementation.

== Hardware Compatibility List ==
The HardwareCompatibility list documents which features outlined in this page are supported by various robot-specific implementations.  Consult this list before developing your application, to determine whether your target robot platform supports all the necessary ROS interfaces.
<P><BR><BR>
----
= Future Plans =
----
This section lists a few ideas we have for expanding the functionality of ROS-Industrial nodes.  These items still need some refinement/discussion, so are not specified above.  We welcome your suggestions on any of these items.  Or, feel free to suggest more features!

 * *Robot Parameters:*
   * provide a pair of services to get/set named "parameters" (i.e. variables) on the robot controller
      * this could be used to set application-specific constants (e.g. job/task name, position-queue variable/index, etc.)
      * or could be used to change robot-driver behavior (e.g. broadcast rate of status messages)
   * on initialization (or `reset`), the ROS node could push down specific ROS parameter values to the robot, allowing control of robot-side parameters from the ROS parameter-server infrastructure
<P>
 * *Cartesian Position/Commands:*
   * publish robot's internal version of its cartesian position/velocity/acceleration
   * command robot motion to specified cartesian points
     * alternatively, command *linear* robot motion between specified joint points
   * singularities and redundant kinematic solutions (i.e. "configurations") may be difficult to handle in a generic manner
   * will require services to set robot-side `BASE` and `TOOL` frames to match their ROS equivalents
<P>
 * *Diagnostics / Logging:*
   * echo `robot_state`, `position`, and other values to ROS [http://www.ros.org/wiki/diagnostics diagnostics] framework
     * for user-level feedback and historical analysis
   * add `Publish Topic` to broadcast a list of *active* robot-side error messages
     * this allows easier display of _current_ vs. _historical_ messages
<P>
 * *Motion:*
   * add flag to control behavior when motion commands are interrupted
     * queue - execute new command _after_ current motion completes
     * interrupt - immediately begin motion to new command
     * stitch - overlay motion commands using trajectory timestamps
     * stop - stop current motion and log an error
     * ignore - ignore new motion command and log an error
     * ... ?
  * add parameter (or service) to control position-streaming buffer size in the robot-side driver
  * add function (service or C++ utility function) to wait for the current motion to complete
  * allow single-step execution of trajectories
     * stop after each point, waiting for a manual `start_motion` call
  * all reverse motion along trajectories
<P>
 * *Logging:*
  * Messages generated on the robot-controller should be logged into the ROS [http://www.ros.org/wiki/rosout logging framework], to facilitate debugging and status-monitoring from remote PCs.
     * this logging should include all common message sources:
        # robot-controller-generated messages
        # ROS robot-side driver messages (e.g. user code)
        * _NOTE: different methods may be required to capture these different message sources_<P>
     * ideally, each message should be logged when first generated/received
<P>
 * *Other:*
   * set feedback publish rates (for position and status)
   * add topics to control robot-connected I/O